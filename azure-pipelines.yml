# Azure DevOps Pipeline for Mess Feedback System
# Terraform + Docker + Azure Container Instances Architecture

trigger:
  branches:
    include:
      - main
      - develop
  paths:
    exclude:
      - README.md
      - docs/*
      - '*.md'

pr:
  branches:
    include:
      - main

variables:
  # Build Variables
  nodeVersion: '18.x'
  dockerRegistryServiceConnection: 'MessFeedback-ACR'
  imageRepository: 'mess-feedback-system'
  containerRegistry: 'messfeedback.azurecr.io'
  dockerfilePath: '$(Build.SourcesDirectory)/Dockerfile'
  tag: '$(Build.BuildId)'
  
  # Azure Variables
  azureServiceConnection: 'MessFeedbackSystem-ServiceConnection'
  resourceGroupName: 'Kavi'
  terraformVersion: '1.13.3'
  
  # Terraform Variables
  TF_VAR_project_name: 'mess-feedback-system'
  TF_VAR_environment: 'prod'
  TF_VAR_location: 'Central India'
  TF_VAR_resource_group_name: 'Kavi'

stages:
  # Build and Test Stage
  - stage: Build
    displayName: 'Build and Test'
    jobs:
      - job: BuildAndTest
        displayName: 'Build Application and Run Tests'
        pool:
          vmImage: 'ubuntu-latest'
        
        steps:
          # Checkout code
          - checkout: self
            displayName: 'Checkout Repository'
          
          # Setup Node.js
          - task: NodeTool@0
            displayName: 'Setup Node.js $(nodeVersion)'
            inputs:
              versionSpec: '$(nodeVersion)'
          
          # Install dependencies
          - script: |
              npm ci
            displayName: 'Install Dependencies'
          
          # Run tests
          - script: |
              npm test || echo "No tests configured, skipping..."
            displayName: 'Run Tests'
            continueOnError: true
          
          # Security audit
          - script: |
              npm audit --audit-level moderate || echo "Security audit completed with warnings"
            displayName: 'Security Audit'
            continueOnError: true

  # Docker Build Stage
  - stage: DockerBuild
    displayName: 'Build Docker Image'
    dependsOn: Build
    jobs:
      - job: BuildImage
        displayName: 'Build and Push Docker Image'
        pool:
          vmImage: 'ubuntu-latest'
        
        steps:
          # Checkout code
          - checkout: self
            displayName: 'Checkout Repository'
          
          # Build and push Docker image
          - task: Docker@2
            displayName: 'Build and Push Docker Image'
            inputs:
              command: 'buildAndPush'
              repository: '$(imageRepository)'
              dockerfile: '$(dockerfilePath)'
              containerRegistry: '$(dockerRegistryServiceConnection)'
              tags: |
                $(tag)
                latest
          
          # Copy Terraform files for next stage
          - task: CopyFiles@2
            displayName: 'Copy Terraform Files'
            inputs:
              SourceFolder: 'terraform'
              Contents: '**'
              TargetFolder: '$(Build.ArtifactStagingDirectory)/terraform'
          
          # Publish Terraform artifacts
          - task: PublishBuildArtifacts@1
            displayName: 'Publish Terraform Artifacts'
            inputs:
              pathToPublish: '$(Build.ArtifactStagingDirectory)'
              artifactName: 'terraform-drop'

  # Terraform Deploy Stage
  - stage: TerraformDeploy
    displayName: 'Deploy Infrastructure with Terraform'
    dependsOn: DockerBuild
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    jobs:
      - deployment: DeployInfrastructure
        displayName: 'Deploy with Terraform'
        pool:
          vmImage: 'ubuntu-latest'
        environment: 'production'
        
        variables:
          TF_VAR_container_image: '$(containerRegistry)/$(imageRepository):$(tag)'
        
        strategy:
          runOnce:
            deploy:
              steps:
                # Download Terraform artifacts
                - download: current
                  artifact: terraform-drop
                
                # Install and Run Terraform via Azure CLI
                - task: AzureCLI@2
                  displayName: 'Deploy Infrastructure with Terraform'
                  inputs:
                    azureSubscription: '$(azureServiceConnection)'
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    inlineScript: |
                      echo "Installing Terraform..."
                      # Install Terraform
                      wget -O- https://apt.releases.hashicorp.com/gpg | sudo gpg --dearmor -o /usr/share/keyrings/hashicorp-archive-keyring.gpg
                      echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/hashicorp.list
                      sudo apt update && sudo apt install terraform
                      
                      echo "Terraform version:"
                      terraform version
                      
                      echo "Navigating to Terraform directory..."
                      cd $(Pipeline.Workspace)/terraform-drop/terraform
                      
                      echo "Initializing Terraform..."
                      terraform init
                      
                      echo "Planning Terraform deployment..."
                      terraform plan -var="container_image=$(TF_VAR_container_image)" -out=tfplan
                      
                      echo "Applying Terraform plan..."
                      terraform apply -auto-approve tfplan
                      
                      echo "Getting Terraform outputs..."
                      terraform output

  # Health Check Stage
  - stage: HealthCheck
    displayName: 'Application Health Check'
    dependsOn: TerraformDeploy
    jobs:
      - job: HealthCheck
        displayName: 'Verify Application Health'
        pool:
          vmImage: 'ubuntu-latest'
        
        steps:
          # Health check script
          - task: PowerShell@2
            displayName: 'Application Health Check'
            inputs:
              targetType: 'inline'
              script: |
                $maxRetries = 10
                $retryCount = 0
                $success = $false
                $appUrl = "http://mess-feedback-system-prod.centralindia.azurecontainer.io:3000"
                
                Write-Host "Starting health check for $appUrl"
                
                while ($retryCount -lt $maxRetries -and -not $success) {
                  try {
                    $retryCount++
                    Write-Host "Health check attempt $retryCount of $maxRetries"
                    
                    # Check main endpoint
                    $response = Invoke-WebRequest -Uri $appUrl -UseBasicParsing -TimeoutSec 30
                    
                    if ($response.StatusCode -eq 200) {
                      Write-Host "‚úÖ Main endpoint health check passed"
                      
                      # Check health endpoint
                      $healthResponse = Invoke-WebRequest -Uri "$appUrl/health" -UseBasicParsing -TimeoutSec 30
                      $healthData = $healthResponse.Content | ConvertFrom-Json
                      
                      if ($healthData.status -eq "OK" -and $healthData.database -eq "connected") {
                        Write-Host "‚úÖ Health endpoint check passed - Database connected"
                        $success = $true
                      } else {
                        Write-Host "‚ùå Health endpoint check failed"
                      }
                    }
                  }
                  catch {
                    Write-Host "‚ùå Health check attempt $retryCount failed: $($_.Exception.Message)"
                    if ($retryCount -lt $maxRetries) {
                      Write-Host "Waiting 30 seconds before retry..."
                      Start-Sleep -Seconds 30
                    }
                  }
                }
                
                if (-not $success) {
                  Write-Error "Health check failed after $maxRetries attempts"
                  exit 1
                } else {
                  Write-Host "üéâ Application deployment successful and healthy!"
                  Write-Host "üåê Application URL: $appUrl"
                  Write-Host "üë®‚Äçüéì Student Portal: $appUrl/student-login"
                  Write-Host "üë®‚Äçüíº Admin Portal: $appUrl/admin-dashboard"
                }
